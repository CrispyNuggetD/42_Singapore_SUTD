# Set up the prompt

# 6 useful things here. +1 Random Daily Login syncing for all these function.

### (1) Includes two aliases 'compile' and 'run' so you don't have 
# to always type in full for 42-compliant compiling/ running
# You can also stack with valgrind flags.

# Usage:
# e.g. compile ft_isalpha.c
# e.g. compile ft_isalpha.c -o output (run with ./output)
# e.g. run ./output
# e.g. run ./output "Hello" 42 (Passing arguments)

# So, feel free to check with memory leaks with -g valgrind flag, i.e.:
# compile -g ft_isalpha.c

# You need to compile with library (behind .c file, order matters) if .a exists, i.e.:
# compile -g ft_isalpha.c libft.a -o output (run with ./output)

### (2) Three helper functions curproj() and syncproj().

# curproj switches into your github repo's project folder 
# and shows the last edit + last sync status.

# cdmain just goes into your github repo.

# syncgithub checks your working tree is clean, and 
# pulls from GitHub. It also pushes if you made changes.
# Run this first before working on another computer to prevent conflicts!
# NOTE: It does NOT touch Vogsphere. 
# SYNC your campus repo before submitting project!

# Usage: Just type curproj, cdmain, or syncproj into terminal.

# Notes:
# You MUST change a few things:

# 1. Change and point the project you're working
# on by changing variable, current_proj="<PROJECT NAME>"
# e.g. current_proj="0_libft"

# 2. Change PROJECTS_ROOTS to Project sub-folder in your repo,
# e.g. export PROJECTS_ROOTS="Core Curriculum/Projects"

# 3. Change MAIN_REPO_ROOT to your GitHub cloned repo on campus PC,
# e.g. export MAIN_REPO_ROOT="$HOME/Documents/42_Singapore_SUTD"

### (3) Zsh backwards cycling keybinds
# Technically Shift + Tab was supposed to work out of the box but
# it didn't for me so I just included it here.

###################################################################
### (APPEND THESE) Variables after changing and Functions       ###
### Do NOT replace original .zshrc file                         ###
###################################################################

# Set up the prompt

# 6 useful things here.

### (1) Includes two aliases 'compile' and 'run' so you don't have 
# to always type in full for 42-compliant compiling/ running
# with valgrind flags everytime.

# Usage:
# e.g. compile ft_isalpha.c
# e.g. compile ft_isalpha.c -o output (run with ./output)
# e.g. run ./output
# e.g. run ./output "Hello" 42 (Passing arguments)

### (2) Three helper functions curproj() and syncproj().

# curproj switches into your github repo's project folder 
# and shows the last edit + last sync status.

# cdmain just goes into your github repo.

# syncgithub checks your working tree is clean, and 
# pulls from GitHub. It also pushes if you made changes.
# Run this first before working on another computer to prevent conflicts!
# NOTE: It does NOT touch Vogsphere. 
# SYNC your campus repo before submitting project!

# Usage: Just type curproj, cdmain, or syncproj into terminal.

# Notes:
# hnah (intra) user defined
export MAIL='hnah@student.42singapore.sg'

# current project name (change as needed, then `source ~/.zshrc`)
export current_proj="0_libft"

# --- 42 paths ---
export PROJECTS_ROOT="Core Curriculum/Projects"
export MAIN_REPO_ROOT="$HOME/Documents/42_Singapore_SUTD"

# --- Zsh backwards cycling ---
bindkey "^[[Z" reverse-menu-complete
bindkey "^[Z" reverse-menu-complete

# compile helper
alias compile='cc -Wall -Wextra -Werror'

# Feel free to check with memory leaks with -g valgrind flag, i.e.
#compile -g

# code execution helper with valgrind and leak flags
alias run='valgrind --leak-check=full --show-leak-kinds=all'

# jump to current 42 project (Vogsphere working copy)
curproj() {
  local proj_dir="$MAIN_REPO_ROOT/$PROJECTS_ROOT/$current_proj"

  if [ ! -d "$proj_dir" ]; then
    echo "No such project directory: $proj_dir"
    return 1
  fi

  cd "$proj_dir" || return 1

  echo "Now working on: $current_proj"
  echo "Location: $proj_dir"

  # --- Last edit (in the 42/Vogsphere clone) ---
  if git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Last local git activity (this 42 project):"
    git log -1 --pretty="  %h %s (%cr)"
  else
    echo "Not a git repo here (no .git found)."
  fi

  # --- Last sync to main GitHub repo ---
  if [ -d "$MAIN_REPO_ROOT/.git" ]; then
    # Get last commit in main repo that touched this project folder
    local last_sync_line
    last_sync_line=$(git -C "$MAIN_REPO_ROOT" log -1 \
      --pretty="%h %s (%cr)" \
      -- "Projects/$current_proj" 2>/dev/null)

    if [ -n "$last_sync_line" ]; then
      echo "Last sync to main repo (GitHub) for this project:"
      echo "  $last_sync_line"

      # Get last sync date in YYYY-MM-DD form
      local last_sync_date today yesterday
      last_sync_date=$(git -C "$MAIN_REPO_ROOT" log -1 \
        --date=short --pretty="%cd" \
        -- "Projects/$current_proj" 2>/dev/null)

      today=$(date +%Y-%m-%d)
      yesterday=$(date -d 'yesterday' +%Y-%m-%d)

      # Warn if last sync was not today or yesterday
      if [ "$last_sync_date" != "$today" ] && [ "$last_sync_date" != "$yesterday" ]; then
        echo "⚠ WARNING: This project hasn't been synced to your main repo in more than a day."
      fi
    else# Set up the prompt

# 6 useful things here.

### (1) Includes two aliases 'compile' and 'run' so you don't have 
# to always type in full for 42-compliant compiling/ running
# with valgrind flags everytime.

# Usage:
# e.g. compile ft_isalpha.c
# e.g. compile ft_isalpha.c -o output (run with ./output)
# e.g. run ./output
# e.g. run ./output "Hello" 42 (Passing arguments)

### (2) Three helper functions curproj() and syncproj().

# curproj switches into your github repo's project folder 
# and shows the last edit + last sync status.

# cdmain just goes into your github repo.

# syncgithub checks your working tree is clean, and 
# pulls from GitHub. It also pushes if you made changes.
# Run this first before working on another computer to prevent conflicts!
# NOTE: It does NOT touch Vogsphere. 
# SYNC your campus repo before submitting project!

# Usage: Just type curproj, cdmain, or syncproj into terminal.

# Notes:
      echo "No sync found for this project in main repo yet."
    fi
  else
    echo "Main repo not found or not a git repo at: $MAIN_REPO_ROOT"
  fi
}

# jump to main GitHub repo
cdmain() {
  cd "$MAIN_REPO_ROOT" || {
    echo "No such main repo directory: $MAIN_REPO_ROOT"
    return 1
  }
} 

# sync current main GitHub repo: pull, then commit & push local changes
syncproj() {
  if [ -z "$MAIN_REPO_ROOT" ]; then
    echo "MAIN_REPO_ROOT is not set. Please set it in your .zshrc."
    return 1
  fi

  if [ ! -d "$MAIN_REPO_ROOT/.git" ]; then
    echo "No git repo found at: $MAIN_REPO_ROOT"
    return 1
  fi

  # jump into main repo
  cd "$MAIN_REPO_ROOT" || {
    echo "Failed to cd into $MAIN_REPO_ROOT"
    return 1
  }

  echo "Syncing main GitHub repo at:"
  echo "  $MAIN_REPO_ROOT"
  echo

  # 1) Always pull latest from GitHub first
  echo "Pulling from remote..."
  git pull
  echo

  # 2) Show current status
  echo "Current status:"
  git status
  echo

  # 3) If no changes, we're done
  if [[ -z "$(git status --porcelain)" ]]; then
    echo "No local changes to commit. Repo is up to date."
    return 0
  fi

  # 4) Stage everything (tracked + untracked + deletions)
  git add -A

  # show status so you see what will be committed
  echo
  echo "Changes staged for commit:"
  git status
  echo

  # 5) Ask for commit title/body (zsh style)
  read "title?Commit title (main repo): "
  read "body?Commit details (optional, leave blank if none): "

  if [[ -n "$body" ]]; then
    git commit -m "$title" -m "$body"
  else
    git commit -m "$title"
  fi

  # 6) Push to GitHub
  git push

  echo
  echo "Committed & pushed with message:"
  echo "--------------------------------"
  echo "$title"
  if [[ -n "$body" ]]; then
    echo
    echo "$body"
  fi
  echo "--------------------------------"
}   

loginbefore12() {
  last "$USER" | awk '
  # Only process normal login lines where $7 is a time like H:MM or HH:MM
  $7 ~ /^[0-9]?[0-9]:[0-9][0-9]$/ {
    day = $4 " " $5 " " $6

    # If we moved to a new day, reset state + buffer
    if (day != cur_day) {
      cur_day = day
      ok = 0
      printed = 0
      nbuf = 0
    }

    # Build exactly the output you wanted (same fields as your print)
    line = $1 " " $4 " " $5 " " $6 " " $7
    for (i=8; i<=13; i++) line = line " " $i

    # Buffer lines until we know the day qualifies
    if (!printed) {
      buf[++nbuf] = line
    }

    # Check if this login was before 12:00
    split($7, t, ":")
    if ((t[1] + 0) < 12) ok = 1

    # If the day qualifies and we haven’t printed it yet, dump the buffer
    if (ok && !printed) {
      for (j=1; j<=nbuf; j++) print buf[j]
      printed = 1
    } else if (printed) {
      # Once we’re printing this day, print subsequent lines immediately
      print line
    }
  }'
}

hourslogged() {
  #!/bin/sh
  # login_award_7day.sh
  #
  # Shows:
  # 1) Per-day login totals for the last 7 days (including today, including zero days)
  # 2) Rolling 7-day total (guaranteed = sum of the printed 7 days)
  # 3) Rolling 7-day average per day
  # 4) Remaining time to reach a 50h rolling-7-days target
  # 5) “Stay logged in until” clock time (e.g., 8:03pm), with date if it crosses midnight
  #
  # Notes:
  # - Counts sessions with explicit duration (HH:MM) like "(02:34)"
  # - Also counts open-ended sessions (e.g., "still logged in", "gone - no logout", etc.) as running until now
  # - Attributes time to the LOGIN DAY (does not split sessions across midnight)

  TARGET_HOURS=50
  TARGET_MIN=$((TARGET_HOURS * 60))

  # Build list of last 7 dates in ISO format (oldest -> newest)
  dates=""
  i=6
  while [ "$i" -ge 0 ]; do
    d="$(date -d "$i days ago" +%F)"
    dates="${dates}${d}
  "
    i=$((i-1))
  done
  export LAST7_DATES="$dates"
  export TODAY="$(date +%F)"

  out="$(
    last "$USER" | awk -v TARGET_MIN="$TARGET_MIN" '
    BEGIN {
      now = systime()

      # Initialize exactly the last 7 ISO dates to 0 so we print zeros too
      n = split(ENVIRON["LAST7_DATES"], D, "\n")
      for (i=1; i<=n; i++) {
        if (D[i] != "") daymin[D[i]] = 0
      }
    }

    function epoch_from_last(dow, mon, dd, hhmm,    cmd, e) {
      cmd = "date -d \"" dow " " mon " " dd " " hhmm "\" +%s"
      cmd | getline e
      close(cmd)
      return e + 0
    }

    function key_from_epoch(e,    cmd, k) {
      cmd = "date -d @" e " +%F"
      cmd | getline k
      close(cmd)
      return k
    }

    # Process lines where $7 is a login time like H:MM or HH:MM
    $7 ~ /^[0-9]?[0-9]:[0-9][0-9]$/ {
      start = epoch_from_last($4, $5, $6, $7)
      if (start <= 0) next

      key = key_from_epoch(start)

      # CRITICAL: only count sessions whose day key is one of our last-7 printed days
      if (!(key in daymin)) next

      # Case 1: explicit duration at end: (HH:MM)
      if (match($0, /\(([0-9]+):([0-9][0-9])\)$/, t)) {
        mins = (t[1] + 0) * 60 + (t[2] + 0)
        daymin[key] += mins
        next
      }

      # Case 2: open-ended / unknown logout (still logged in / gone - no logout / crash / etc.)
      mins = int((now - start) / 60)
      if (mins < 0) mins = 0
      daymin[key] += mins
    }

    END {
      # Per-day totals (chronological)
      n = split(ENVIRON["LAST7_DATES"], D, "\n")
      print "Per-day login totals (last 7 days):"
      for (i=1; i<=n; i++) {
        if (D[i] == "") continue

        cmd = "date -d \"" D[i] "\" +%a"
        cmd | getline wd
        close(cmd)

        h = int(daymin[D[i]] / 60)
        m = daymin[D[i]] % 60
        printf "%s (%s): %dh %02dm\n", D[i], wd, h, m
      }

      # Rolling total = sum of the same 7 printed days (cannot disagree)
      roll = 0
      for (i=1; i<=n; i++) {
        if (D[i] != "") roll += daymin[D[i]]
      }

      roll_h = int(roll / 60)
      roll_m = roll % 60

      # Rolling average per day (over 7 days, including zeros)
      avg = int(roll / 7)
      avg_h = int(avg / 60)
      avg_m = avg % 60

      print ""
      printf "Rolling 7-day total: %dh %02dm\n", roll_h, roll_m
      printf "Rolling 7-day average per day: %dh %02dm\n", avg_h, avg_m

      remaining = TARGET_MIN - roll
      if (remaining < 0) remaining = 0

      rh = int(remaining / 60)
      rm = remaining % 60

      print ""
      printf "Target (rolling 7 days): %dh 00m\n", int(TARGET_MIN / 60)
      printf "Remaining to reach target: %dh %02dm\n", rh, rm

      if (remaining == 0) {
        print "You already hit the 50h rolling-7-days award ✅"
      } else {
        printf "If you stay logged in from now, you need ~%dh %02dm more.\n", rh, rm
      }

      # machine-readable for shell:
      printf "REM_MIN=%d\n", remaining
    }'
  )"

  # Print human output (everything except REM_MIN line)
  printf "%s\n" "$out" | awk '!/^REM_MIN=/'

  # Extract remaining minutes
  rem_min="$(printf "%s\n" "$out" | awk -F= '/^REM_MIN=/{print $2; exit}')"
  [ -z "$rem_min" ] && rem_min=0

  # Compute the clock time to stay logged in until
  echo ""
  if [ "$rem_min" -eq 0 ]; then
    echo "Stay logged in until: now (already achieved)"
  else
    finish_time="$(date -d "now + $rem_min minutes" +"%I:%M%p")"
    finish_day="$(date -d "now + $rem_min minutes" +"%F")"
    today="$(date +%F)"

    # Format like 8:03pm (not 08:03PM)
    finish_time="$(printf "%s" "$finish_time" | tr 'APM' 'apm' | sed 's/^0//')"

    if [ "$finish_day" = "$today" ]; then
      echo "Stay logged in until: $finish_time"
    else
      finish_label="$(date -d "now + $rem_min minutes" +"%a %Y-%m-%d")"
      echo "Stay logged in until: $finish_time ($finish_label)"
    fi
  fi
}

divider() {
    printf "\n\033[1;36m%*s\033[0m\n" "$(tput cols)" '' | tr ' ' '='
}

dailylogin() {

  divider
  echo "Days that I logged in before 12nn"
  divider
  
  zsh -ic 'loginbefore12'
  
  divider
  echo "Hours logged for (50 hrs Intra_Award)"
  divider
  
  zsh -ic 'hourslogged'
  
  divider
  echo "sync proj. with github"
  divider
  
  zsh -ic 'syncproj'
  
  divider
  echo "cd to current project"
  divider
  
  zsh -ic 'curproj'
}
